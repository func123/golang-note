

​	在看非main g的退出前，先看下它的创建

```go
func main() {
	go func() {
		for {
			fmt.Println()
		}
	}()
	time.Sleep(time.Second * 5)
}

// 终端执行：go tool compile -N -l -S main.go
// 找到对应的汇编代码
MOVL    $0, (SP)	// 将gorountine执行的函数参数大小放到SP对应地址上，这里是 0 
PCDATA  $0, $1	
LEAQ    "".main.func1·f(SB), AX		
PCDATA  $0, $0
MOVQ    AX, 8(SP)	// 设置函数地址
CALL    runtime.newproc(SB)	
```

​	从上面可以看出g的创建会调用`runtime.newproc`函数，接下来具体看一下

```go
// Create a new g running fn with siz bytes of arguments.
// Put it on the queue of g's waiting to run.
// The compiler turns a go statement into a call to this.
// Cannot split the stack because it assumes that the arguments
// are available sequentially after &fn; they would not be
// copied if a stack split occurred.
//go:nosplit
func newproc(siz int32, fn *funcval) {
	argp := add(unsafe.Pointer(&fn), sys.PtrSize)
	gp := getg()
	pc := getcallerpc()
	systemstack(func() {
		newproc1(fn, (*uint8)(argp), siz, gp, pc)
	})
}
```







非main g退出后将返回到`runtime·goexit`中继续执行，下面继续来看

```go
// The top-most function running on a goroutine
// returns to goexit+PCQuantum.
TEXT runtime·goexit(SB),NOSPLIT,$0-0
	BYTE	$0x90	// NOP
	CALL	runtime·goexit1(SB)	// does not return
	// traceback from goexit1 must hit code range of goexit
	BYTE	$0x90	// NOP

// runtime/proc.go
// Finishes execution of the current goroutine.
func goexit1() {
	if raceenabled {
		racegoend()
	}
	if trace.enabled {
		traceGoEnd()
	}
	mcall(goexit0)
}
```

​	goroutine在退出后一路执行到`mcall`，这里作用主要是保存g的调度信息，将g0放入到线程本地存储，切换到g0栈

```go
// func mcall(fn func(*g))
// Switch to m->g0's stack, call fn(g).
// Fn must never return. It should gogo(&g->sched)
// to keep running g.
TEXT runtime·mcall(SB), NOSPLIT, $0-8
	MOVQ	fn+0(FP), DI	// 将参数放到DI寄存器上
	// 保存g的调度信息
	get_tls(CX)			
	MOVQ	g(CX), AX	// save state in g->sched 	// 将g放入AX寄存器
	MOVQ	0(SP), BX	// caller's PC	
	MOVQ	BX, (g_sched+gobuf_pc)(AX)		//保存g的调度信息到g.gobuf中
	LEAQ	fn+0(FP), BX	// caller's SP
	MOVQ	BX, (g_sched+gobuf_sp)(AX)
	MOVQ	AX, (g_sched+gobuf_g)(AX)
	MOVQ	BP, (g_sched+gobuf_bp)(AX)

	// switch to m->g0 & its stack, call fn	
	// 找到g0
	MOVQ	g(CX), BX	// BX = g
	MOVQ	g_m(BX), BX	// BX = g.m
	MOVQ	m_g0(BX), SI	// SI = g.m.g0
	// 错误退出保护
	CMPQ	SI, AX	// if g == m->g0 call badmcall
	JNE	3(PC)
	MOVQ	$runtime·badmcall(SB), AX
	JMP	AX
	// 恢复g0的调度信息到对应寄存器，从g栈切换到g0栈
	MOVQ	SI, g(CX)	// g = m->g0  // 将g0设置到线程本地存储中
	MOVQ	(g_sched+gobuf_sp)(SI), SP	// sp = m->g0->sched.sp 
	PUSHQ	AX			// AX=g，这里入栈作为后面调用goexit0函数的参数
	MOVQ	DI, DX		// DX = goexit0（结构体funcval实例对象的指针）
	MOVQ	0(DI), DI	// goexit0
	CALL	DI		// 调用 goexit0 函数
	POPQ	AX
	MOVQ	$runtime·badmcall2(SB), AX
	JMP	AX
	RET
```

​	`mcall`函数主要做了三件事：

1. 将g的调度信息保存起来
2. 通过`g.m.g0`找到g0，放入到线程本地存储中，并且恢复g0的调度信息到寄存器上，完成g-->g0栈的切换
3. 在g0栈上调用 `goexit0`函数

做完这些事情，接下来就在g0栈上执行`goexit0`函数

```go
// goexit continuation on g0.
func goexit0(gp *g) {	// gp = g 
	_g_ := getg()	// 获取g0

	casgstatus(gp, _Grunning, _Gdead)	// 设置g的状态为_Gdead
	if isSystemGoroutine(gp, false) {
		atomic.Xadd(&sched.ngsys, -1)
	}
    // 清除g的相关状态
	gp.m = nil	// 将 g 和 m 解绑
	locked := gp.lockedm != 0
	gp.lockedm = 0
	_g_.m.lockedg = 0
	gp.paniconfault = false
	gp._defer = nil // should be true already but just in case.
	gp._panic = nil // non-nil for Goexit during panic. points at stack-allocated data.
	gp.writebuf = nil
	gp.waitreason = 0
	gp.param = nil
	gp.labels = nil
	gp.timer = nil

	······

	// Note that gp's stack scan is now "valid" because it has no
	// stack.
	gp.gcscanvalid = true
	dropg()

	······
    
    // 将 g 放入到p的空闲队列中，便于重用
	gfput(_g_.m.p.ptr(), gp)
    
	······
    
	schedule()
}
```

​	g的生命周期至此就结束了：`g()->goexit()->goexit1()->mcall()`，在`macll`中切换到g0栈，之后通过调用`goexit0`函数清除g的相关状态信息，并且与m解绑后放入到p的空闲队列中以便下次被重用。最后通过调用`schedule`开始新一轮的调度